# 에러 보고서: React 무한 업데이트 루프

## 📋 에러 개요

**에러 타입**: `Maximum update depth exceeded`  
**발생 위치**: `useNamecardEditor.js:141`  
**심각도**: 🔴 Critical (앱이 완전히 멈춤)

## 🔍 에러 메시지

```
Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
```

## 📊 에러 스택 트레이스 분석

### 호출 체인

```
1. EventDetailView.js:57
   └─ useEffect에서 bindProfile 호출
   
2. useNamecardEditor.js:180
   └─ commands.bindProfile 실행
   
3. EditorCore.js:263
   └─ bindProfile 메서드 실행
   
4. EditorCore.js:652
   └─ notifySubscribers() 호출
   
5. EditorCore.js:654
   └─ subscribe 콜백 실행
   
6. useNamecardEditor.js:141
   └─ setState() 호출 ← 여기서 무한 루프 시작
   
7. EventDetailView 리렌더링
   └─ useEffect 재실행
   
8. 1번으로 돌아가서 반복...
```

## 🐛 근본 원인 분석

### 1. 순환 의존성 문제

**위치**: `components/EventDetailView.js:55-60`

```javascript
// 선택된 프로필이 변경될 때 에디터에 바인딩
useEffect(() => {
  if (editor?.commands && selectedProfile) {
    editor.commands.bindProfile(selectedProfile)
  }
}, [selectedProfile?.id, editor?.commands])  // ← 문제: editor?.commands가 매번 새 객체
```

**문제점**:
- `editor?.commands`는 `useNamecardEditor`에서 `useCallback`으로 생성되지만, 의존성 배열이 비어있어도 `editor` 객체 자체가 변경될 수 있음
- `bindProfile`이 호출되면 → `EditorCore.notifySubscribers()` → `setState` → 리렌더링 → `editor` 객체 재생성 → `useEffect` 재실행 → 무한 루프

### 2. EditorCore의 notifySubscribers가 setState를 직접 트리거

**위치**: `hooks/useNamecardEditor.js:130-141`

```javascript
// 상태 구독
unsubscribe = core.subscribe((newState) => {
  if (isMounted) {
    setState(prev => ({
      ...prev,
      ...newState  // ← 전체 상태를 덮어쓰면서 무한 루프 유발 가능
    }))
  }
})
```

**문제점**:
- `bindProfile`이 호출되면 `EditorCore`의 `state.currentProfileId`가 변경됨
- `notifySubscribers()`가 호출되어 `setState`가 트리거됨
- `setState`로 인해 `editor` 객체가 재생성됨
- `EventDetailView`의 `useEffect`가 `editor?.commands` 변경을 감지하여 다시 `bindProfile` 호출

### 3. 의존성 배열의 불안정한 참조

**위치**: `components/EventDetailView.js:55-60`

```javascript
useEffect(() => {
  if (editor?.commands && selectedProfile) {
    editor.commands.bindProfile(selectedProfile)
  }
}, [selectedProfile?.id, editor?.commands])  // ← editor?.commands는 매번 새 객체일 수 있음
```

**문제점**:
- `editor` 객체는 `useNamecardEditor`에서 반환되는데, 내부 `setState`가 호출될 때마다 재생성될 수 있음
- `editor?.commands`는 객체이므로 참조가 변경되면 `useEffect`가 재실행됨

## 🔧 문제가 발생하는 코드 위치

### 1. EventDetailView.js (55-60줄)

```javascript
// 선택된 프로필이 변경될 때 에디터에 바인딩
useEffect(() => {
  if (editor?.commands && selectedProfile) {
    editor.commands.bindProfile(selectedProfile)
  }
}, [selectedProfile?.id, editor?.commands])  // ← 문제
```

### 2. useNamecardEditor.js (130-141줄)

```javascript
// 상태 구독
unsubscribe = core.subscribe((newState) => {
  if (isMounted) {
    setState(prev => ({
      ...prev,
      ...newState  // ← 전체 상태 덮어쓰기
    }))
  }
})
```

### 3. EditorCore.js (261-263줄)

```javascript
this.canvas.renderAll()
this.state.currentProfileId = profile?.id
this.notifySubscribers()  // ← setState 트리거
```

## 📈 에러 발생 패턴

1. **초기 렌더링**: `EventDetailView` 마운트
2. **프로필 선택**: `selectedProfile` 변경
3. **useEffect 실행**: `bindProfile` 호출
4. **EditorCore 업데이트**: `notifySubscribers()` 호출
5. **setState 트리거**: `useNamecardEditor`의 `setState` 실행
6. **리렌더링**: `editor` 객체 재생성
7. **useEffect 재실행**: `editor?.commands` 변경 감지
8. **무한 반복**: 3번으로 돌아가서 반복

## 🎯 영향 범위

- ✅ **직접 영향**: `EventDetailView` 컴포넌트가 렌더링 불가
- ✅ **간접 영향**: 전체 앱이 멈춤 (React의 무한 루프 감지로 에러 발생)
- ✅ **성능**: CPU 사용률 급증, 메모리 누수 가능성

## 💡 해결 방안 제안

### 방안 1: useEffect 의존성 배열 수정

```javascript
// EventDetailView.js
useEffect(() => {
  if (editor?.commands && selectedProfile) {
    editor.commands.bindProfile(selectedProfile)
  }
}, [selectedProfile?.id])  // editor?.commands 제거
```

### 방안 2: bindProfile 호출 최적화

```javascript
// EventDetailView.js
const bindProfileRef = useRef(null)

useEffect(() => {
  bindProfileRef.current = editor?.commands?.bindProfile
}, [editor?.commands?.bindProfile])

useEffect(() => {
  if (bindProfileRef.current && selectedProfile) {
    bindProfileRef.current(selectedProfile)
  }
}, [selectedProfile?.id])
```

### 방안 3: EditorCore의 notifySubscribers 최적화

```javascript
// EditorCore.js
notifySubscribers() {
  // 상태가 실제로 변경되었을 때만 알림
  const currentState = { ...this.state }
  if (JSON.stringify(currentState) === JSON.stringify(this.lastNotifiedState)) {
    return  // 변경사항이 없으면 알림 생략
  }
  this.lastNotifiedState = currentState
  this.subscribers.forEach(callback => {
    try {
      callback(currentState)
    } catch (error) {
      console.error('Error in subscriber callback:', error)
    }
  })
}
```

### 방안 4: useNamecardEditor의 setState 최적화

```javascript
// useNamecardEditor.js
unsubscribe = core.subscribe((newState) => {
  if (isMounted) {
    setState(prev => {
      // 실제로 변경된 필드만 업데이트
      const hasChanges = Object.keys(newState).some(
        key => prev[key] !== newState[key]
      )
      if (!hasChanges) return prev  // 변경사항이 없으면 업데이트 생략
      return { ...prev, ...newState }
    })
  }
})
```

## 📝 추가 발견된 문제

1. **EditorCore 초기화 중복**: `initAttempted` 플래그가 있지만 완벽하게 작동하지 않음
2. **메모리 누수 가능성**: 무한 루프로 인한 이벤트 리스너 누적
3. **성능 저하**: 불필요한 리렌더링으로 인한 CPU 사용률 증가

## 🔍 디버깅 정보

- **에러 발생 빈도**: 프로필 선택 시마다 발생
- **재현 조건**: 
  1. 이벤트 페이지 접속
  2. 프로필 선택
  3. 즉시 무한 루프 발생
- **브라우저 콘솔**: "Maximum update depth exceeded" 경고 반복 출력
- **React DevTools**: 컴포넌트 트리가 계속 업데이트됨

## 📅 보고서 작성일

2025-01-27

## 👤 보고자

AI Assistant (에러 분석 및 보고서 작성)

---

**참고**: 이 보고서는 에러 분석을 위한 것이며, 실제 수정은 개발자가 수행해야 합니다.

