# 해결책.md 검토 결과

## 📋 검토 개요

해결책.md에 제시된 문제 분석과 해결 방안을 현재 코드와 비교하여 검토했습니다.

## ✅ 문제 분석 정확도

### 1. 문제 상황 재현 - **정확함** ✅
- 명단 클릭 → 프로필 바인딩 → 텍스트 이동 시도 → 초기화/드래그 끊김
- 현재 코드에서 실제로 발생 가능한 시나리오입니다.

### 2. 근본 원인 분석 - **매우 정확함** ✅

#### ✅ Y좌표 정렬 의존 문제
**현재 코드 확인:**
```javascript:577:580:components/CanvasEditor_new.js
// 🔥 새로운 로직: 텍스트 객체들을 Y 좌표 순으로 정렬하여 순서대로 업데이트
const textObjects = objects
  .filter(obj => obj.type === 'i-text')
  .sort((a, b) => (a.top || 0) - (b.top || 0))
```
- **문제 확인됨**: 텍스트를 이동하면 다음 바인딩 시 잘못된 필드로 매핑될 수 있음

#### ✅ 동일 프로필 재바인딩 문제
**현재 코드 확인:**
```javascript:1414:1432:components/CanvasEditor_new.js
useEffect(() => {
  if (!fabricCanvasRef.current || !isCanvasReady) return
  if (isLoading) {
    console.log('CanvasEditor: Skipping profile update - template loading in progress')
    return
  }
  if (selectedProfile) {
    console.log('CanvasEditor: Updating canvas with profile:', selectedProfile.name)
    updateCanvasWithProfile(selectedProfile)
  }
}, [selectedProfile, isCanvasReady, updateCanvasWithProfile, isLoading])
```
- **문제 확인됨**: 시그니처 가드가 없어 동일 프로필도 재바인딩됨

#### ✅ 강제 선택 문제
**현재 코드 확인:**
```javascript:636:652:components/CanvasEditor_new.js
if (updatedTextObjects.length > 0 && onPropertyChange) {
  const nameObject = updatedTextObjects.find(obj => 
    obj.text === profile.name || 
    obj.text === (profile.name || '이름')
  ) || updatedTextObjects[1] || updatedTextObjects[0]
  
  setTimeout(() => {
    if (nameObject && canvas) {
      canvas.setActiveObject(nameObject)
      canvas.renderAll()
      onPropertyChange('selectedObject', nameObject)
    }
  }, 150)
}
```
- **문제 확인됨**: 드래그 중에도 강제 선택이 발생할 수 있음

#### ✅ ref 전달 혼선
**현재 코드 확인:**
```javascript:143:160:components/EventDetailView.js
const handleCanvasRef = useCallback((canvasInstance) => {
  if (!canvasInstance) {
    console.log('EventDetailView: Invalid canvas instance received')
    return
  }
  if (canvasRef && canvasRef.fabricCanvasRef === canvasInstance.fabricCanvasRef) {
    console.log('EventDetailView: Same canvas instance, skipping update')
    return
  }
  console.log('EventDetailView: Setting new canvas instance:', canvasInstance)
  setCanvasRef(canvasInstance)
  setCanvasMethods(canvasInstance)
}, [canvasRef])
```
- **문제 확인됨**: DOM 엘리먼트와 메서드 객체가 혼재될 가능성

---

## 🎯 해결책 평가

### 1. dataField 태그 부여 - **우수한 해결책** ⭐⭐⭐⭐⭐

**현재 상태:**
- ❌ `createDefaultTemplate`에 dataField 없음
- ❌ `toJSON()` 호출 시 커스텀 속성 미포함
- ❌ 템플릿 로딩 시 dataField 복원 없음

**제안된 해결책:**
```javascript
// 기본 템플릿 생성 시
const companyText = new fabric.IText('회사명', {
  // ... 기존 속성들
  dataField: 'company'  // ✅ 추가
})

// JSON 저장 시
const data = canvas.toJSON(['dataField'])  // ✅ 커스텀 속성 포함

// 템플릿 로딩 시
const textObj = new fabric.IText(objData.text || '', {
  // ... 기존 속성들
  dataField: objData.dataField  // ✅ 복원
})
```

**평가:**
- ✅ Y좌표 의존성 완전 제거
- ✅ 텍스트 위치 변경에도 안정적 매핑
- ✅ 하위 호환성 고려 (구버전 템플릿 지원)
- ✅ 구현 난이도: 낮음

**권장사항:** 즉시 적용 권장

---

### 2. 필드 태그 기반 매핑 - **우수한 해결책** ⭐⭐⭐⭐⭐

**현재 코드:**
```javascript:577:632:components/CanvasEditor_new.js
// Y좌표 정렬 후 index로 매핑 (불안정)
const textObjects = objects
  .filter(obj => obj.type === 'i-text')
  .sort((a, b) => (a.top || 0) - (b.top || 0))

textObjects.forEach((obj, index) => {
  if (index === 0) obj.set('text', profile.company || '회사명')
  else if (index === 1) obj.set('text', profile.name || '이름')
  else if (index === 2) obj.set('text', profile.title || '직급')
})
```

**제안된 해결책:**
```javascript
const getByField = (field, fallbacks = []) => {
  let obj = objects.find(o => o.type === 'i-text' && o.dataField === field)
  if (!obj) {
    // 구버전 템플릿 호환
    obj = objects.find(o => o.type === 'i-text' && fallbacks.includes(o.text))
    if (obj) obj.set('dataField', field)
  }
  return obj
}

const companyObj = getByField('company', ['회사명', 'Company', '회사', 'company'])
const nameObj = getByField('name', ['이름', 'Name', '성명', 'fullname'])
const titleObj = getByField('title', ['직급', 'Title', 'Position', '부서'])

if (companyObj) companyObj.set('text', profile.company ?? '회사명')
if (nameObj) nameObj.set('text', profile.name ?? '이름')
if (titleObj) titleObj.set('text', profile.title ?? '직급')
```

**평가:**
- ✅ 위치 독립적 매핑
- ✅ 구버전 템플릿 자동 마이그레이션
- ✅ 코드 가독성 향상
- ✅ 구현 난이도: 낮음

**권장사항:** 즉시 적용 권장

---

### 3. 동일 프로필 재바인딩 차단 - **필수 해결책** ⭐⭐⭐⭐⭐

**현재 코드:**
```javascript:1414:1432:components/CanvasEditor_new.js
useEffect(() => {
  if (selectedProfile) {
    updateCanvasWithProfile(selectedProfile)  // ❌ 매번 호출
  }
}, [selectedProfile, ...])
```

**제안된 해결책:**
```javascript
const lastProfileSigRef = useRef('')

useEffect(() => {
  if (!selectedProfile) return
  
  const sig = [
    selectedProfile.id ?? '',
    selectedProfile.name ?? '',
    selectedProfile.company ?? '',
    selectedProfile.title ?? ''
  ].join('|')
  
  if (lastProfileSigRef.current === sig) {
    console.log('CanvasEditor: Profile unchanged; skip rebinding')
    return  // ✅ 동일 프로필이면 스킵
  }
  
  updateCanvasWithProfile(selectedProfile)
  lastProfileSigRef.current = sig
}, [selectedProfile, ...])
```

**평가:**
- ✅ 불필요한 재바인딩 완전 차단
- ✅ 드래그 중 끊김 현상 해결
- ✅ 성능 개선
- ✅ 구현 난이도: 매우 낮음

**권장사항:** 최우선 적용 권장

---

### 4. 강제 선택 최소화 - **중요한 개선** ⭐⭐⭐⭐

**현재 코드:**
```javascript:636:652:components/CanvasEditor_new.js
setTimeout(() => {
  if (nameObject && canvas) {
    canvas.setActiveObject(nameObject)  // ❌ 항상 실행
    canvas.renderAll()
    onPropertyChange('selectedObject', nameObject)
  }
}, 150)
```

**제안된 해결책:**
```javascript
// 프로필이 실제 변경되어 바인딩된 경우에만 1회 선택
if (nameObject && canvas) {
  canvas.setActiveObject(nameObject)
  canvas.renderAll()
  onPropertyChange('selectedObject', nameObject)
}
// setTimeout 제거 또는 드래그 감지 후 조건부 실행
```

**평가:**
- ✅ 드래그 중 간섭 최소화
- ⚠️ 사용자 경험 개선 (자동 선택이 유용할 수도 있음)
- ✅ 구현 난이도: 낮음

**권장사항:** 적용 권장 (조건부 실행으로 개선 가능)

**개선 제안:**
```javascript
// 드래그 중이 아닐 때만 자동 선택
const isDraggingRef = useRef(false)

canvas.on('mouse:down', () => { isDraggingRef.current = false })
canvas.on('object:moving', () => { isDraggingRef.current = true })
canvas.on('mouse:up', () => { isDraggingRef.current = false })

if (nameObject && canvas && !isDraggingRef.current) {
  canvas.setActiveObject(nameObject)
  canvas.renderAll()
  onPropertyChange('selectedObject', nameObject)
}
```

---

### 5. ref 전달 통일 - **권장 개선** ⭐⭐⭐

**현재 코드:**
```javascript:143:160:components/EventDetailView.js
const handleCanvasRef = useCallback((canvasInstance) => {
  // DOM 엘리먼트와 메서드 객체 혼재 가능성
  setCanvasRef(canvasInstance)
  setCanvasMethods(canvasInstance)
}, [canvasRef])
```

**제안된 해결책:**
```javascript
// onTemplateLoad만 사용, onCanvasRef 제거
const handleCanvasRef = useCallback((methods) => {
  if (!methods) return
  setCanvasRef(methods)     // methods.fabricCanvasRef 등만 사용
  setCanvasMethods(methods)
}, [])
```

**평가:**
- ✅ ref 혼선 방지
- ✅ 불필요한 리렌더 감소
- ⚠️ 기존 코드와의 호환성 확인 필요
- ✅ 구현 난이도: 중간

**권장사항:** 적용 권장 (다른 컴포넌트 영향 확인 후)

---

## 📊 종합 평가

### 해결책 품질: ⭐⭐⭐⭐⭐ (5/5)

**장점:**
1. ✅ 문제 원인을 정확히 파악
2. ✅ 근본적인 해결책 제시
3. ✅ 하위 호환성 고려
4. ✅ 단계별 구현 가이드 제공
5. ✅ 체크리스트 제공

**개선 제안:**
1. 드래그 감지 로직 추가 (강제 선택 최소화 개선)
2. 마이그레이션 전략 (기존 템플릿 자동 업그레이드)

---

## 🚀 적용 우선순위

### 1순위: 동일 프로필 재바인딩 차단
- **영향도**: 매우 높음 (드래그 끊김 해결)
- **난이도**: 매우 낮음
- **예상 효과**: 즉시 개선

### 2순위: dataField 태그 부여 + 필드 태그 기반 매핑
- **영향도**: 매우 높음 (근본 원인 해결)
- **난이도**: 낮음
- **예상 효과**: 안정성 대폭 향상

### 3순위: 강제 선택 최소화
- **영향도**: 중간 (사용자 경험 개선)
- **난이도**: 낮음
- **예상 효과**: 드래그 중 간섭 감소

### 4순위: ref 전달 통일
- **영향도**: 낮음 (성능 최적화)
- **난이도**: 중간
- **예상 효과**: 리렌더 감소

---

## ✅ 최종 권장사항

**해결책.md의 제안은 매우 우수하며 즉시 적용을 권장합니다.**

1. ✅ 문제 분석이 정확함
2. ✅ 해결책이 근본적이고 실용적임
3. ✅ 구현 난이도가 낮음
4. ✅ 하위 호환성 고려됨

**다음 단계:**
1. 1순위부터 순차적으로 적용
2. 각 단계별 테스트 수행
3. 기존 템플릿 마이그레이션 확인

---

**검토일**: 2025-11-12  
**검토자**: AI Assistant  
**검토 결과**: ✅ 즉시 적용 권장

